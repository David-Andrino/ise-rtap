\subsection{Interfaz táctil}

\subsubsection{El alto nivel}
Una vez se ha configurado una función de bajo nivel para representar los píxeles en la pantalla, que se explica en el apartado \ref{}, se pueden utilizar las abstracciones de alto nivel que ofrece LVGL. 

La interfaz gráfica de RTAP consta de 4 pestañas: Inicio, Radio, MP3 y Filtros. A su vez, cada pestaña dispone de un lienzo en color gris claro, sobre el que se añaden paneles, con un fondo blanco y un borde gris de 2 píxeles de grosor. Cada panel implementa una funcionalidad, o muestra la información relevante. Todas las pestañas comparten una filosofía: Los paneles principales ocupan la totalidad de la pantalla, haciendo la interfaz muy intuitiva, y, si se desliza el panel hacia la parte superior, se muestran los créditos del proyecto: El título, la asignatura y los estudiantes involucrados. Además, todo el proyecto utiliza la fuente \textit{Montserrat}, variando el tamaño según la importancia del contenido. A continuación, se explica cada una de las pestañas, excluyendo el panel de créditos. 

\textbf{Inicio}

La pestaña de inicio consta de dos paneles principales: Configuración rápida y Consumo.
\begin{itemize}
    \item \textbf{Configuración rápida:} Este panel está formado por tres grupos de botones. El primer y el segundo grupo se emplean para seleccionar la salida y la entrada, respectivamente. Como el sistema no permite la opción de seleccionar las dos entradas o las dos salidas simultáneamente, estos botones son excluyentes: marcar uno desmarca el otro. Como estilo, se ha optado por un color azul claro para representar la opción seleccionada, y un color más oscuro para la no seleccionada. Por último, este panel tiene un botón que hace que el sistema entre en modo de bajo consumo. Los botones se distribuyen según una rejilla fija, y los grupos de estos se dividen mediante un espaciado uniforme, calculado de manera dinámica por LVGL.
    \item \textbf{Consumo:} Este panel está formado por una escala en forma de arco, que ocupa 225º de la circunferencia. Además, se le aplica una rotación de 180º para conseguir la posición deseada, que deja espacio suficiente para colocar una etiqueta de texto. 
    
    La escala, que se utiliza para representar de forma gráfica el consumo del sistema, admite valores entre 0 y 1500, que se interpretan como miliamperios. A la escala se le aplican tres formatos diferentes: El primero es un color verde, para los valores entre 0 y 375, el segundo, un color azul, entre 375 y 1125, y el tercero, en rojo, para los valores más altos, entre 1125 y 1500. En total, la escala cuenta con 25 \textit{ticks}, y cada 4 de estos, se introduce uno principal, es decir, para los valores más significativos, de 0 A, 0.25 A, 0.5 A, 0.75 A, 1 A , 1.25 A y 1.5 A. Estos \textit{ticks} principales tienen un grosor de 2 píxeles, mientras que los secundarios tienen un grosor de 1 píxel. LVGL calcula la longitud de cada \textit{tick} de manera dinámica. Por último, la escala cuenta con una aguja, en color rojo y con una longitud máxima de 80 píxeles, que apunta al valor del consumo instantáneo, que además se representa en la etiqueta de texto.

    El panel se organiza según una rejilla flexible organizada en forma de columna. Esto significa que simplemente se declaran los objetos y se les da un tamaño, y LVGL los coloca de forma dinámica apilados verticalmente. Sin embargo, para conseguir que la etiqueta se muestre en el lugar apropiado, se le da una posición fija relativa al panel.
\end{itemize}

\textbf{Radio}

La pestaña de radio está formada por tres paneles principales: Uno para la radio, otro para el volumen, y otro para la salida.

\begin{itemize}
    \item \textbf{Radio:} Este panel es el más grande de esta pestaña, ocupando dos terceras partes del espacio. Este panel es muy complejo, estando formado por una superposición de elementos. De manera simple: En la parte posterior encontramos un título, que indica que el panel es para sintonizar una frecuencia. En la posición inmediatamente inferior, se muestra un número, que en caso de no tener ningún valor, se mostrará en color sombreado. Hay varias formas de modificar este valor, que se detallan más adelante. Después encontramos una escala, que simula la apariencia de una radio clásica, y cuyos valores, entre 87 y 108, se interpretan como megahercios. Sin embargo, en un primer plano, encima de la escala, encontramos un slider, del cual solo se representa el mando, en color rojo y con un borde negro. En LVGL un slider solo puede tener valores enteros, por lo que este toma valores entre 870 y 1080, para mantener un decimal, interpretándose el valor como centenas de kilohercio. En la parte inferior hay un espacio en blanco, cuya utilidad se comenta a continuación, y después hay una fila con un objeto en forma de caja, inicialmente vacío, y a su derecha, tres botones.

    Empezando por el slider, que puede ser la opción más intuitiva, un deslizamiento sobre la escala tendrá diferentes consecuencias: El texto que tiene encima se modificará, acompañando el valor del texto, y, en caso de ser una cadena conocida, en el espacio en blanco que se mencionó anteriormente, se representará el texto correspondiente al nombre de la cadena. Sin embargo, para no saturar la cola de mensajes ni a la radio, la cadena marcada sólo se sintoniza una vez se ha soltado el slider.

    Otra posible forma de modificar el valor de la frecuencia es mediante los botones de \textit{Seek}. El sistema busca la siguiente cadena con una señal aceptable, la sintoniza, y modifica el valor del texto y del slider. Otra opción es tocar el valor del texto, y se desplegará un teclado numérico, que permite sintonizar de manera rápida y precisa una cadena, solo en caso de haber introducido un valor correcto. En caso de que el valor introducido no sea un valor posible, o sea un número mal formado, el slider se truncará hacia el valor correcto más próximo. Para cerrar el teclado, se puede utilizar cualquiera de los dos botones pensados para ello, o tocar en cualquier parte de la pantalla.

    Además, se dispone de un botón de favoritos, que almacenará en la caja todas las cadenas que se quieran guardar (no es persistente). En caso de que se conozca el nombre de la cadena, será esto lo que se muestre en la lista, en caso contrario, se mostrará únicamente la frecuencia. Para recuperar cualquier cadena guardada, solo habrá que buscarla en la lista.

    Por último, destacar que cualquier cambio en la web se verá reflejado de forma inmediata en el slider y en todos los cuadros de texto.
    \item \textbf{Volumen:} Este panel permite ajustar el volumen global del sistema. Se mantiene sincronizado con los paneles de volumen de otras pestañas, y presenta un botón de mute, que ejecuta una animación, variando el valor hasta 0 de forma suave, o, en caso de estar ya en cero, aumentándolo hasta la posición previa. Igual que con otros sliders, para no saturar los mecanismos de sincronización, el valor solo es enviado una vez se ha soltado.
    \item \textbf{Salida:} Este panel también permite seleccionar la salida del sistema. Se mantiene sincronizado con los botones que ofrecen la misma función en otras pestañas, y mantiene el mismo estilo que el de la pestaña de inicio para indicar cuál es la opción seleccionada.
\end{itemize}

\textbf{MP3}

La pestaña del MP3 mantiene muchas similitudes con la de la radio: Se compone de tres paneles, de los cuales el principal también ocupa dos tercios de la pantalla, y los dos paneles de su derecha son idénticos a los explicados anteriormente. 

El panel principal del MP3 también es un panel muy complejo. En este caso, el panel a su vez está compuesto por varios paneles. En un primer momento, se aprecian los 3 botones principales del MP3: anterior, play/pause y siguiente. El color de estos botones se ha pensado para romper con la monotonía del sistema, dando una impresión más alegre. El degradado se calcula automáticamente por LVGL, no se aplica ninguna textura que ocupe memoria.

En la parte inferior del panel hay una pestaña, que si se desliza hacia arriba, pasa a ocupar el 70\% del subpanel. Sin embargo, a los botones se les permite ocupar el 40\% del panel, con esto se logra la impresión de que los botones no terminan de esconderse nunca. Esta pestaña representa la lista de canciones que se tiene almacenada en la tarjeta SD. Al hacer click sobre una canción, esta se envía al MP3, y además, se reproduce una animación, que sustituye durante unos segundos al título de la pestaña, representando la canción. Nuevamente, si se oculta la lista de canciones, los botones de control pasan a ocupar el 100\% de su panel.

\textbf{Filtros}

La pestaña correspondiente a los filtros muestra las opciones de ecualización del sistema, además de algunos ajustes para el audio. En concreto, esta pestaña consta de 4 paneles: 
\begin{itemize}
    \item \textbf{Ecualizador:} Es el panel principal de la pestaña, y ocupa la mitad de esta. Se compone de 5 sliders, que manejan cada uno una banda. Como en sliders anteriores, el valor únicamente se envía cuando se libera el slider. Modificar un valor en la página web ejecuta una animación para sincronizar el valor.
    \item \textbf{Volumen:} Tiene un tamaño ligeramente inferior al de las pestañas anteriores, pero mantiene el mismo valor y funcionalidad.
    \item \textbf{Guardar config:} Es un pequeño panel con un único botón, para almacenar la configuración.
    \item \textbf{Configuración de audio:} Es parecido al panel de configuración rápida de la pestaña de inicio, manteniendo el estilo y todos los botones, excepto el de bajo consumo, que en este caso es reemplazado por un botón para restablecer el valor de los filtros. Pulsar el botón hace que se ejecuten 5 animaciones, una para cada slider, poniendo su valor a cero de forma suave.
\end{itemize}

\subsection{La parte técnica}
La placa STM32F769-disco que se ha utilizado en este proyecto dispone de una pantalla LCD táctil de 4.3", con una resolución de 800 x 480 píxeles y una profundidad del color de 16 bit. Esto permite crear interfaces gráficas atractivas, y, gracaias al uso de las DMA, con un coste computacional asumible. Por tanto, después de estudiar las diferentes opciones disponibles, se ha diseñado una interfaz completa, que permite el control completo del sistema.
\subsubsection{Software y librerías disponibles}
A la hora de crear una interfaz gráfica, la opción más lógica es utilizar una librería de más alto nivel, o un software de creación de interfaces, para abstraer el manejo de cada píxel individual, pero, en el mundo de los microcontroladores, estas opciones son bastante limitadas. Algunas de las opciones que se han estudiado son:
\begin{itemize}
  \item \textbf{Embedded Wizard:} Este software permite la creación de interfaces gráficas de una manera aparentemente sencilla, pero es código cerrado, y para utilizarlo de forma gratuita hay que asumir una marca de agua con su logo. Además, tienen su propio sistema operativo, que si bien no es muy distinto de las opciones conocidas, maximiza el riesgo de fallo a la hora de, por ejemplo, implementar el servidor web. Por tanto, esta opción se descartó.
  \item \textbf{EmWin:} Este software es la herramienta de Keil para la creación de interfaces, y viene incluida como \textit{software pack} dentro del programa. Incluye una función de generación de interfaces \textit{drag and drop}, lo que significa que, desde su programa, solo hay que colocar los elementos que se quieran tener en la interfaz en su sitio adecuado, todo desde una interfaz gráfica, abstrayendo el código. Sin embargo, las opciones de este software son muy limitadas, y las interfaces que genera tienen un aspecto rudimentario y obsoleto, por lo que esta opción también se descartó.
  \item \textbf{TouchGFX:} Este software, propiedad de STM, presenta una interfaz gráfica para la generación automática de código. Es un software muy potente, con el que es fácil generar interfaces modernas y visualmente atractivas. Además, incluye numerosos ejemplos, tanto en su aplicación, como en CubeMX. En un principio, se seleccionó esta opción, pero presenta el problema de ser de código cerrado, y es muy difícil adaptar el código que se genera para que sea compatible con Keil. Por tanto, finalmente se descartó.
  \item \textbf{LVGL:} Little Versatile Graphic Library es una librería de código abierto ampliamente utilizada en el mundo profesional. Varias empresas multinacionales, como Xiaomi o LG, utilizan actualmente adaptaciones de esta librería en algunos de sus productos. Es cierto que esta opción no dispone aún de herramientas para la generación automática de código, pero la librería es relativamente fácil de manejar. Con LVGL se pueden generar interfaces de todo tipo, y para el proyecto se ha seleccionado por su versatilidad y su fácil manejo. Además, ahora está presente en Keil como \textit{Software Pack}, por lo que su integración es absoluta. En nuestro proyecto, se utiliza la versión 9.1, que en el momento de redacción e implementación del proyecto, es la última versión estable de la librería.
\end{itemize}
\subsubsection{El bajo nivel}
LVGL es una librería de alto nivel, que es capaz de dibujar formas sobre un \textit{array}. Sin embargo, es responsabilidad de la persona que implementa la librería, el representar este \textit{array} en la pantalla. De este modo, el programador genera una función que representa un conjunto de píxeles en su pantalla, y LVGL se encarga de llamar a esta función cuando corresponda. Es decir, el tiempo de refresco de la pantalla variará según las necesidades del momento, liberando el uso de CPU cuando la pantalla tiene una imagen estática.

La primera aproximación posible para esta función es un simple bucle: itera todo el \textit{array} de píxeles y los envía a la pantalla. Sin embargo, esta aproximación es muy intensiva en el uso de CPU, además de poco eficiente. Por ello, una vez se ha determinado que el funcionamiento de la pantalla y el de LVGL es correcto, conviene modificarla. En el caso de RTAP, esta función utiliza la DMA 2, el \textit{Stream} 2 y el Canal 2, en configuración \textit{Memory To Memory}, consiguiendo alcanzar la tasa de refresco máxima que soporta la pantalla, de 30 fps, con un uso de la CPU mínimo, excepto cuando se ejecutan animaciones, que el uso de CPU aumenta considerablemente.

Una de las razones por las que la tasa de refresco disminuye es por el modo de funcionamiento de LVGL: admite diferentes configuraciones de \textit{buffer} que pasará como parámetro a la función de bajo nivel. En nuestro proyecto se utilizan de manera simultánea dos \textit{buffers} (la pantalla lee de uno mientras el controlador escribe en otro, y luego conmutan), pero cada uno solamente es del tamaño de la décima parte de la pantalla. Gracias a esta configuración es posible ahorrar mucha memoria, a cambio de un mayor uso de la CPU.

\subsubsection{Consideraciones sobre la pantalla y el bajo consumo}
La pantalla de la placa es un periférico complejo, que, como se ha explicado, utiliza la DMA para representar una imagen. Pero, cuando se entra en modo bajo consumo, la pantalla accede constantemente a los mismos datos: el reloj del procesador está parado, por lo que la información de los píxeles no se actualiza. Esto tiene un efecto indeseado, que es que la pantalla no se apaga, se queda con la última imagen que se cargó antes de entrar en modo de bajo consumo, lo que implica que el consumo es mayor del deseado. Por tanto hay que tomar la precaución de apagar la pantalla antes de entrar en este modo. RTAP implementa esta funcionalidad de manera transparente para el usuario: la aplicación apaga la pantalla cuando entra en modo de bajo consumo en cualquier caso, independientemente de que la orden se envíe desde el botón destinado a ello en la interfaz táctil o en la interfaz web.

\subsubsection{Consideraciones sobre LVGL}
\textbf{Sobre la memoria}

Después de haber repasado de forma general la interfaz del proyecto, se entiende que para representar un sistema tan complejo hace falta una cantidad considerable de memoria. En concreto, se asignan 131072 bytes de memoria a LVGL, y un stack de 12400 bytes al hilo que gestiona el funcionamiento de LVGL. La cantidad de memoria empleada es más que suficiente para el correcto funcionamiento de la placa, se deja un margen de en torno al 30\%. 

Para el proyecto de RTAP es necesario ser generosos con la cantidad de memoria de LVGL, porque, si bien es cierto que solo se mantiene en memoria los objetos que se están representando en el momento, hay diferentes elementos cuya cantidad de memoria variará entre dos usos de la aplicación. En concreto, estos elementos son: la lista de emisoras guardadas de la radio, y la lista de canciones del MP3. No se puede determinar con antelación el número de emisoras que almacenará el usuario, o el número de canciones que se deben representar. La configuración empleada está pensada para soportar cualquier caso de uso.

\textbf{Sobre los objetos}

En LVGL un objeto es un \textit{struct} con información sobre este. Los objetos en LVGL son extremadamente genéricos, hasta el punto de que, para la librería, un panel contenedor de botones es del mismo tipo que los propios botones, que a su vez son del mismo tipo que un teclado, que un \textit{slider} o que una escala. Esto implica una dificultad, y es que es que es muy sencillo pasar como parámetro un objeto equivocado a una función, con el correspondiente efecto indeseado, que suele ser un \textit{Hard Fault}, pero, también ofrece la ventaja del concepto de jerarquía: Independientemente del tipo de objeto, será hijo de otro objeto. El puntero al objeto padre se incluye en el \textit{struct} que define un objeto, además de punteros a todos los objetos hijos. El único tipo de objeto que no tiene padre es especial, y es la propia pantalla. Se pueden definir varias pantallas, pero en RTAP se trabaja únicamente con una, de modo que cualquier objeto es accesible para los demás a través de su árbol (esto evita el uso de variables globales).

\textbf{Sobre los eventos}

LVGL tiene diferentes métodos de notificación de eventos, muy útiles en un sistema orientado a eventos, como es una interfaz gráfica. Hay tres grandes grupos de eventos en nuestro proyecto: los generados por la pantalla, los generados por la web, y los generados periódicamente por el programa. En LVGL, un evento no es más que un \textit{struct} con la información pertinente, que incluye el objeto que lo provocó e información relevante, como el tipo de evento.

En cuanto a los primeros, desde la interfaz gráfica se asignan funciones de \textit{callback} a los objetos que las deben de generar, como los botones o \textit{sliders}. Como en LVGL un evento contiene la información sobre el tipo de evento, se pueden tomar numerosas decisiones. Por ejemplo, RTAP solo notifica de que un \textit{slider} ha variado su valor una vez se ha soltado, para no saturar a las colas de sincronización, pero, en el caso del \textit{slider} de la frecuencia de la radio, sí que se toma una acción mientras se está variando la posición de este: se representa el nombre de la cadena en el lugar específico. Por otro lado, desde la interfaz gráfica se pueden tomar acciones que afectarán a otros objetos del sistema: el botón de \textit{mute} (de cualquier pestaña) ejecuta una animación en el \textit{slider} del volumen, y el botón de restablecimiento de los valores de los filtros ejecuta animaciones en los \textit{sliders} de estos.

Todos los eventos se notifican a la web mediante elementos de sincronización, explicados en \ref{Error}. Cabe destacar que, desde el hilo que gestiona la pantalla y desde las diferentes funciones de \textit{callback}, no se toman acciones que afectan al sistema en general, únicamente se envían mensajes de control, para que un hilo controlador ejecute las acciones pertinentes.

Los eventos generados por la web presentan una dificultad: al ser la web un elemento invisible para LVGL, no se puede asignar una función de \textit{callback} directamente. Afortunadamente, la librería implementa métodos de notificación de eventos generados externamente, pero se debe de tener en cuenta otra consideración: el evento se notificará en el próximo refresco de la pantalla. Para cuidar la calidad del audio y evitar cortes, RTAP incluye un mecanismo que limita la tasa máxima de refresco de la pantalla. De este modo, cuando se está ejecutando una animación, por ejemplo, un cambio de pestaña, LVGL no ocupa toda la CPU, evitando así cortes molestos en el sonido. Pero esto implica que, como máximo, LVGL será notificado de un evento a los 15 milisegundos, siendo más común una notificación cada 33 milisegundos (30 refrescos por segundo). Si se genera más de un evento en este tiempo, se perderá. Por ello es importante que los \textit{sliders} de la web envíen también su valor únicamente cuando el usuario ha soltado el mismo, de otro modo, el comportamiento es impredecible. 

El último grupo de eventos es para los que no se provocan ni por la web ni por la pantalla, aunque, para LVGL, este tipo es exactamente igual que los de la web. Simplemente es algo que LVGL no puede predecir ni gestionar. En nuestro caso, el consumo entra dentro de este grupo, cuyo valor se mide cada segundo, y se notifica al hilo controlador de la pantalla, que a su vez lo representa en la interfaz.