\subsubsection{Módulo de LCD}
\paragraph{La parte técnica}
La placa STM32F769-disco que se ha utilizado en este proyecto dispone de una pantalla LCD táctil de 4.3", con una resolución de 800 x 480 píxeles y una profundidad del color de 16 bit. Esto permite crear interfaces gráficas atractivas, y, gracaias al uso de las DMA, con un coste computacional asumible. Por tanto, después de estudiar las diferentes opciones disponibles, se ha diseñado una interfaz completa, que permite el control completo del sistema.
\paragraph{Software y librerías disponibles}
A la hora de crear una interfaz gráfica, la opción más lógica es utilizar una librería de más alto nivel, o un software de creación de interfaces, para abstraer el manejo de cada píxel individual, pero, en el mundo de los microcontroladores, estas opciones son bastante limitadas. Algunas de las opciones que se han estudiado son:
\begin{itemize}
  \item \textbf{Embedded Wizard:} Este software permite la creación de interfaces gráficas de una manera aparentemente sencilla, pero es código cerrado, y para utilizarlo de forma gratuita hay que asumir una marca de agua con su logo. Además, tienen su propio sistema operativo, que si bien no es muy distinto de las opciones conocidas, maximiza el riesgo de fallo a la hora de, por ejemplo, implementar el servidor web. Por tanto, esta opción se descartó.
  \item \textbf{EmWin:} Este software es la herramienta de Keil para la creación de interfaces, y viene incluida como \textit{software pack} dentro del programa. Incluye una función de generación de interfaces \textit{drag and drop}, lo que significa que, desde su programa, solo hay que colocar los elementos que se quieran tener en la interfaz en su sitio adecuado, todo desde una interfaz gráfica, abstrayendo el código. Sin embargo, las opciones de este software son muy limitadas, y las interfaces que genera tienen un aspecto rudimentario y obsoleto, por lo que esta opción también se descartó.
  \item \textbf{TouchGFX:} Este software, propiedad de STM, presenta una interfaz gráfica para la generación automática de código. Es un software muy potente, con el que es fácil generar interfaces modernas y visualmente atractivas. Además, incluye numerosos ejemplos, tanto en su aplicación, como en CubeMX. En un principio, se seleccionó esta opción, pero presenta el problema de ser de código cerrado, y es muy difícil adaptar el código que se genera para que sea compatible con Keil. Por tanto, finalmente se descartó.
  \item \textbf{LVGL:} Little Versatile Graphic Library es una librería de código abierto ampliamente utilizada en el mundo profesional. Varias empresas multinacionales, como Xiaomi o LG, utilizan actualmente adaptaciones de esta librería en algunos de sus productos. Es cierto que esta opción no dispone aún de herramientas para la generación automática de código, pero la librería es relativamente fácil de manejar. Con LVGL se pueden generar interfaces de todo tipo, y para el proyecto se ha seleccionado por su versatilidad y su fácil manejo. Además, ahora está presente en Keil como \textit{Software Pack}, por lo que su integración es absoluta. En nuestro proyecto, se utiliza la versión 9.1, que en el momento de redacción e implementación del proyecto, es la última versión estable de la librería.
\end{itemize}
\paragraph{El bajo nivel}
\label{subsubsec:bajo-nivel}
LVGL es una librería de alto nivel, que es capaz de dibujar formas sobre un \textit{array}. Sin embargo, es responsabilidad de la persona que implementa la librería, el representar este \textit{array} en la pantalla. De este modo, el programador genera una función que representa un conjunto de píxeles en su pantalla, y LVGL se encarga de llamar a esta función cuando corresponda. Es decir, el tiempo de refresco de la pantalla variará según las necesidades del momento, liberando el uso de CPU cuando la pantalla tiene una imagen estática.

La primera aproximación posible para esta función es un simple bucle: itera todo el \textit{array} de píxeles y los envía a la pantalla. Sin embargo, esta aproximación es muy intensiva en el uso de CPU, además de poco eficiente. Por ello, una vez se ha determinado que el funcionamiento de la pantalla y el de LVGL es correcto, conviene modificarla. En el caso de RTAP, esta función utiliza la DMA 2, el \textit{Stream} 2 y el Canal 2, en configuración \textit{Memory To Memory}, consiguiendo alcanzar la tasa de refresco máxima que soporta la pantalla, de 30 fps, con un uso de la CPU mínimo, excepto cuando se ejecutan animaciones, que el uso de CPU aumenta considerablemente.

Una de las razones por las que la tasa de refresco disminuye es por el modo de funcionamiento de LVGL: admite diferentes configuraciones de \textit{buffer} que pasará como parámetro a la función de bajo nivel. En nuestro proyecto se utilizan de manera simultánea dos \textit{buffers} (la pantalla lee de uno mientras el controlador escribe en otro, y luego conmutan), pero cada uno solamente es del tamaño de la décima parte de la pantalla. Gracias a esta configuración es posible ahorrar mucha memoria, a cambio de un mayor uso de la CPU.

\paragraph{Consideraciones sobre la pantalla y el bajo consumo}
\label{subsubsec:apagar-pantalla}
La pantalla de la placa es un periférico complejo, que, como se ha explicado, utiliza la DMA para representar una imagen. Pero, cuando se entra en modo bajo consumo, la pantalla accede constantemente a los mismos datos: el reloj del procesador está parado, por lo que la información de los píxeles no se actualiza. Esto tiene un efecto indeseado, que es que la pantalla no se apaga, se queda con la última imagen que se cargó antes de entrar en modo de bajo consumo, lo que implica que el consumo es mayor del deseado. Por tanto hay que tomar la precaución de apagar la pantalla antes de entrar en este modo. RTAP implementa esta funcionalidad de manera transparente para el usuario: la aplicación apaga la pantalla cuando entra en modo de bajo consumo en cualquier caso, independientemente de que la orden se envíe desde el botón destinado a ello en la interfaz táctil o en la interfaz web.

\paragraph{Consideraciones sobre LVGL}
\textbf{Sobre la memoria}

Después de haber repasado de forma general la interfaz del proyecto, se entiende que para representar un sistema tan complejo hace falta una cantidad considerable de memoria. En concreto, se asignan 131072 bytes de memoria a LVGL, y un stack de 12400 bytes al hilo que gestiona el funcionamiento de LVGL. La cantidad de memoria empleada es más que suficiente para el correcto funcionamiento de la placa, se deja un margen de en torno al 30\%. 

Para el proyecto de RTAP es necesario ser generosos con la cantidad de memoria de LVGL, porque, si bien es cierto que solo se mantiene en memoria los objetos que se están representando en el momento, hay diferentes elementos cuya cantidad de memoria variará entre dos usos de la aplicación. En concreto, estos elementos son: la lista de emisoras guardadas de la radio, y la lista de canciones del MP3. No se puede determinar con antelación el número de emisoras que almacenará el usuario, o el número de canciones que se deben representar. La configuración empleada está pensada para soportar cualquier caso de uso.

\textbf{Sobre los objetos}

En LVGL un objeto es un \textit{struct} con información sobre este. Los objetos en LVGL son extremadamente genéricos, hasta el punto de que, para la librería, un panel contenedor de botones es del mismo tipo que los propios botones, que a su vez son del mismo tipo que un teclado, que un \textit{slider} o que una escala. Esto implica una dificultad, y es que es que es muy sencillo pasar como parámetro un objeto equivocado a una función, con el correspondiente efecto indeseado, que suele ser un \textit{Hard Fault}, pero, también ofrece la ventaja del concepto de jerarquía: Independientemente del tipo de objeto, será hijo de otro objeto. El puntero al objeto padre se incluye en el \textit{struct} que define un objeto, además de punteros a todos los objetos hijos. El único tipo de objeto que no tiene padre es especial, y es la propia pantalla. Se pueden definir varias pantallas, pero en RTAP se trabaja únicamente con una, de modo que cualquier objeto es accesible para los demás a través de su árbol (esto evita el uso de variables globales).

\textbf{Sobre los eventos}

LVGL tiene diferentes métodos de notificación de eventos, muy útiles en un sistema orientado a eventos, como es una interfaz gráfica. Hay tres grandes grupos de eventos en nuestro proyecto: los generados por la pantalla, los generados por la web, y los generados periódicamente por el programa. En LVGL, un evento no es más que un \textit{struct} con la información pertinente, que incluye el objeto que lo provocó e información relevante, como el tipo de evento.

En cuanto a los primeros, desde la interfaz gráfica se asignan funciones de \textit{callback} a los objetos que las deben de generar, como los botones o \textit{sliders}. Como en LVGL un evento contiene la información sobre el tipo de evento, se pueden tomar numerosas decisiones. Por ejemplo, RTAP solo notifica de que un \textit{slider} ha variado su valor una vez se ha soltado, para no saturar a las colas de sincronización, pero, en el caso del \textit{slider} de la frecuencia de la radio, sí que se toma una acción mientras se está variando la posición de este: se representa el nombre de la cadena en el lugar específico. Por otro lado, desde la interfaz gráfica se pueden tomar acciones que afectarán a otros objetos del sistema: el botón de \textit{mute} (de cualquier pestaña) ejecuta una animación en el \textit{slider} del volumen, y el botón de restablecimiento de los valores de los filtros ejecuta animaciones en los \textit{sliders} de estos.

Todos los eventos se notifican a la web mediante elementos de sincronización, explicados en \autoref{subsubsec:modulo-control}. Cabe destacar que, desde el hilo que gestiona la pantalla y desde las diferentes funciones de \textit{callback}, no se toman acciones que afectan al sistema en general, únicamente se envían mensajes de control, para que un hilo controlador ejecute las acciones pertinentes.

Los eventos generados por la web presentan una dificultad: al ser la web un elemento invisible para LVGL, no se puede asignar una función de \textit{callback} directamente. Afortunadamente, la librería implementa métodos de notificación de eventos generados externamente, pero se debe de tener en cuenta otra consideración: el evento se notificará en el próximo refresco de la pantalla. Para cuidar la calidad del audio y evitar cortes, RTAP incluye un mecanismo que limita la tasa máxima de refresco de la pantalla. De este modo, cuando se está ejecutando una animación, por ejemplo, un cambio de pestaña, LVGL no ocupa toda la CPU, evitando así cortes molestos en el sonido. Pero esto implica que, como máximo, LVGL será notificado de un evento a los 15 milisegundos, siendo más común una notificación cada 33 milisegundos (30 refrescos por segundo). Si se genera más de un evento en este tiempo, se perderá. Por ello es importante que los \textit{sliders} de la web envíen también su valor únicamente cuando el usuario ha soltado el mismo, de otro modo, el comportamiento es impredecible. 

El último grupo de eventos es para los que no se provocan ni por la web ni por la pantalla, aunque, para LVGL, este tipo es exactamente igual que los de la web. Simplemente es algo que LVGL no puede predecir ni gestionar. En nuestro caso, el consumo entra dentro de este grupo, cuyo valor se mide cada segundo, y se notifica al hilo controlador de la pantalla, que a su vez lo representa en la interfaz, concretamente en la pestaña de inicio, como se explica en \autoref{subsubsec:alto-nivel}.